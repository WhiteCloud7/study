<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>&#x4e00;&#x4e9b;&#x5173;&#x952e;&#x5b57;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="一些关键字">一些关键字</h1>
<h2 id="this">this:</h2>
<p><strong>记住就是当前对象的引用即可</strong>，例如</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">this</span>.name = name;
    }
}
</code></pre>
<p>这里就是当前对象的name，即当前对象的<code>private String name</code>，这里是处理同名，this()同理，而且this()必须放在第一行。另外，单独的this()表示调用当前类的无参构造函数，有参的话就是调用当前类的有参构造函数。</p>
<h2 id="super">super:</h2>
<p><strong>记住就是父类对象的引用即可</strong>，例如</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> {
        <span class="hljs-built_in">super</span>.setName(name);
    }
}
</code></pre>
<p>那么这里就是父类的name，即父类的<code>private String name</code>，这里是处理同名，super()同理。
其他的和this()一样，<strong>但是super()由于继承机制，必须放在重写的父类方法的内第一行，而不能放在重写父类方法的外部。</strong></p>
<h2 id="static">static:</h2>
<ul>
<li>被static修饰的变量或者方法，是属于类的，而不是属于对象的，<em>即静态变量或者静态方法，可以直接通过类名来访问，而不需要实例化对象。</em></li>
<li><strong>静态方法中不能使用this和super关键字</strong>，因为静态方法是属于类的，而不是属于对象的，所以this和super关键字是不能使用的。</li>
<li><strong>静态类只能访问静态变量或者静态方法，反之非静态类可以随意访问静态变量或者静态方法</strong>。</li>
<li><strong>static不是全局变量。一个属性被写在类最外部，那么这个属性就是全局变量。而static是将属性变成静态属性，可通过类名来直接访问</strong>。</li>
<li>一个类实例化，该类中带static是属于类的而不是对象，故无论实例化多少个对象都共享该属性，而不带static的属性则每实例化一个都是不同的属性，例如</li>
</ul>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String name;
    <span class="hljs-keyword">private</span> String age;
}
</code></pre>
<h2 id="age实例化的age1age2age3都是不同的而name实例化的name1name2name3都是相同的"><strong>age实例化的age1，age2，age3都是不同的，而name实例化的name1，name2，name3都是相同的</strong>。</h2>
<h1 id="一些方法及一些必要的基本概念">一些方法及一些必要的基本概念</h1>
<h2 id="newstring">newString():</h2>
<p>new String(byte[] bytes, int offset, int length, String charsetName)</p>
<ul>
<li>bytes：这是一个 byte 类型的数组，它包含了需要转换为字符串的字节数据。在文件读取的场景中，这个数组通常是从文件中读取到的字节内容。</li>
<li>offset：这是一个整数，表示从 bytes 数组的哪个位置开始进行转换。索引从 0 开始计数。例如，若 - - offset 为 0，则从数组的第一个字节开始转换。</li>
<li>length：同样是一个整数，指定了要转换的字节数量。它决定了从 offset 位置开始，取多少个字节进行字符串转换。</li>
<li>charsetName：这是一个字符串，代表了字符编码的名称</li>
</ul>
<h2 id="try-catch">try-catch:</h2>
<ul>
<li>try-catch: 用于捕获异常，当try中的代码出现异常时，会跳转到catch中，catch中的代码会被执行,格式为</li>
</ul>
<pre><code class="language-java"><span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 可能会抛出异常的代码 </span>
}
<span class="hljs-keyword">catch</span> (Exception e) {
    <span class="hljs-comment">// 异常处理代码 </span>
}
</code></pre>
<ul>
<li>try-resource-catch: 除了捕获异常，还可以用于资源的释放，格式为</li>
</ul>
<pre><code class="language-java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>()) {
    <span class="hljs-comment">// 使用资源的代码</span>
}
<span class="hljs-keyword">catch</span> (Exception e) {
    <span class="hljs-comment">// 异常处理代码 </span>
}
</code></pre>
<p><strong>注意，这里的资源是所有相关的资源都会关闭,<code>BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()))</code>不仅关闭了BufferedReader还会关闭右边包括socket在内的所有资源。</strong></p>
<ul>
<li>try-finally-catch: 除了捕获异常，还可以用于资源的释放，格式为</li>
</ul>
<pre><code class="language-java"><span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// 可能会抛出异常的代码</span>
}
<span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// 无论是否抛出异常，都会执行的代码</span>
}
</code></pre>
<ul>
<li><strong>一些必须要抛出异常的方法：如IO、Socket、线程、数据库等</strong>。</li>
</ul>
<h2 id="继承">继承：</h2>
<ul>
<li>父类可以有多个子类，子类可以有多个子类，但是子类只能有一个父类。</li>
<li>子类继承父类的所有属性和方法，但是父类的私有属性和方法不能被继承，但在父类建立公共的方法来访问，如getter和setter方法。</li>
<li><strong>子类直接使用父类的属性，<em>重写</em>父类的方法</strong>，也可以添加新的属性和方法。</li>
</ul>
<h2 id="接口">接口：</h2>
<ul>
<li>接口可以被多个类实现，一个类可以实现多个接口。</li>
<li><strong>接口全部是抽象方法。而抽象类可以有抽象方法也可以有非抽象方法。</strong></li>
<li>接口不能被实例化，但是可以被实现。</li>
<li>接口可以继承接口，但是不能继承类。</li>
</ul>
<h2 id="内部类">内部类：</h2>
<ol>
<li><strong>成员内部类</strong>，格式为：</li>
</ol>
<pre><code class="language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> {
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> {
        <span class="hljs-comment">// 内部类的代码</span>
    }
}
</code></pre>
<ul>
<li>成员内部类可以访问外部类的所有属性和方法，包括私有属性和方法。<em><strong>（除了静态内部类另外的都和成员内部类相同）</strong></em></li>
<li>成员内部类可以被实例化，但是必须先实例化外部类，然后再实例化内部类,格式为：</li>
</ul>
<pre><code class="language-java"><span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();
Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();
或
Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>().<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();
</code></pre>
<ol start="2">
<li>静态内部类</li>
</ol>
<ul>
<li>静态内部类可以访问外部类的所有<strong>静态</strong>属性和方法，包括私有静态属性和方法。</li>
<li>静态内部类可以被实例化，但是不需要实例化外部类,格式为：<code>Outer.Inner inner = new Outer.Inner();</code></li>
</ul>
<ol start="3">
<li>局部内部类
局部内部类权限和成员内部类一样，但是局部内部类只能在方法中定义和使用，不能在类中定义和使用。</li>
<li><strong>匿名内部类</strong>
匿名内部类用于只是用一次的类，可以继承一个父类或者实现一个接口(都是重写方法)，继承和接口的格式都类似为：</li>
</ol>
<pre><code class="language-java"><span class="hljs-type">MyClass</span> <span class="hljs-variable">class</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>(可选参数) {
    <span class="hljs-comment">// 重写MyClass中的方法</span>
}
</code></pre>
<h2 id="lambda表达式">lambda表达式：</h2>
<p>lambda表达式的语法为：</p>
<pre><code class="language-java">(参数列表) -&gt; {
    <span class="hljs-comment">// 方法体</span>
}
如
<span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// 方法体</span>
    }
});
用lambda表达式表示为（由于run方法没有参数故参数列表也没有）：
<span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; {
                    <span class="hljs-comment">// 方法体</span>
                }).start();

</code></pre>
<h2 id="whiletrue">while（true）</h2>
<p>while（true）为除非被停止的死循环，可以用作需要一直运行的方法。<strong>另外死循环会导致程序一直停在这出不来，所以对于所有死循环，如果该程序还有其他需要运行的，需要给死循环开启一个线程</strong></p>
<h2 id="数值转化">数值转化：</h2>
<ul>
<li>强制类型转换：<code>(类型)变量名</code>，高精度向低精度转换时会丢失精度，低精度向高精度转换时会自动转换，<em>精度排行：byte(8) &lt; short(16) &lt; int(32) &lt; long(32) &lt; float(32) &lt; double(64)。</em>
如<code>short a= 8;int b = (int)a</code></li>
<li>字符串和数值的转换（以int为例）：字符转整型有<code>Integer.parseInt(String s)</code>和<code>Integer.valueOf(String s)</code>，整型转字符有<code>String.valueOf(int i)</code>和<code>Integer.toString(int i)</code>。</li>
<li>日期和字符串的转换：时间和字符串:format parse 格式:××formatter，例如：</li>
</ul>
<pre><code class="language-java">    <span class="hljs-comment">// 获取当前日期时间</span>
    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();
    <span class="hljs-comment">// 定义日期格式</span>
    <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);
    <span class="hljs-comment">// 将日期转换为字符串</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">dateString</span> <span class="hljs-operator">=</span> now.format(formatter);
  
    <span class="hljs-comment">// 定义日期字符串</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">dateString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2024-10-01 12:30:00&quot;</span>;
    <span class="hljs-comment">// 定义日期格式</span>
    <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);
    <span class="hljs-comment">// 将字符串转换为日期</span>
    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDateTime.parse(dateString, formatter);
</code></pre>
<h2 id="计时">计时：</h2>
<ul>
<li>System.currentTimeMillis()-start(start为在开始计时的System.currentTimeMillis())</li>
<li>用schedule
<ul>
<li>schedule(TimerTask task, long delay)：在指定延迟delay（以毫秒为单位）后执行task任务。</li>
<li>schedule(TimerTask task, Date time)：在指定的Date时间执行task任务。</li>
<li>schedule(TimerTask task, long delay, long period)：在延迟delay毫秒后开始执行task任务，之后每隔period毫秒重复执行。</li>
<li>schedule(TimerTask task, Date firstTime, long period)：在firstTime指定的时间开始执行task任务，之后每隔period毫秒重复执行。</li>
<li>使用固定格式：</li>
</ul>
<pre><code class="language-java"><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();
<span class="hljs-type">TimerTask</span> <span class="hljs-variable">timerTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() {
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>{
    <span class="hljs-comment">// 任务代码</span>
		};
timer.schedule(参数);}
</code></pre>
</li>
</ul>
<hr>
<h1 id="io流">IO流：</h1>
<p>参考博客：(IO流)[<a href="https://blog.csdn.net/a1405/article/details/116766237">https://blog.csdn.net/a1405/article/details/116766237</a>]</p>
<h2 id="字节流">字节流</h2>
<p>字节流以字节为单位进行数据的读写操作，可处理任意类型的数据，如图片、音频、视频等，在文件上传、下载、传输等场景中广泛应用。使用时需注意关闭输入输出流，否则可能导致数据写入失败。</p>
<ul>
<li>节点流
FileInputStream 和 FileOutputStream：用于文件的读取和写入操作，可实现文件复制等功能。在开发中，文件的上传、下载等操作常使用这两个节点流，通常会与装饰后的处理流配合使用。</li>
<li>处理流:ByteArrayInputStream 和 ByteArrayOutputStream：用于在内存中临时存储和操作字节数据，可将数据存储在字节数组中进行读写。</li>
<li>缓冲流：BufferedInputStream 和 BufferedOutputStream 是字节流的缓冲流，通过设置缓冲区，减少与数据源的交互次数，提高数据传输效率。</li>
</ul>
<h2 id="字符流">字符流</h2>
<p>字符流以字符为单位进行数据的读写操作，主要用于处理纯文本文件。在进行纯文本文件的 I/O 操作时，通常会配合处理流一起使用。</p>
<ul>
<li>节点流
FileReader 和 FileWriter：用于纯文本文件的读取和写入操作，针对文本数据的处理更加方便。
StringReader 和 StringWriter：用于在内存中临时存储和操作字符数据，可将数据存储在字符串中进行读写。</li>
<li>缓冲流：BufferedReader 和 BufferedWriter 是字符流的缓冲流，同样通过设置缓冲区，提高文本数据的读写效率，并且 BufferedReader 提供了按行读取的便捷方法。</li>
<li>转换流：InputStreamReader 和 OutputStreamWriter 用于在字节流和字符流之间进行转换，可指定字符编码，默认编码为 UTF - 8。在处理不同编码的文本文件时非常有用。</li>
</ul>
<h1 id="socket网络编程">Socket网络编程：</h1>
<h2 id="socket">Socket:</h2>
<p>参考博客：(Scoket)[<a href="https://blog.csdn.net/weixin_49561506/article/details/131554978">https://blog.csdn.net/weixin_49561506/article/details/131554978</a>]</p>
<ol>
<li>Socket:</li>
</ol>
<pre><code class="language-java">服务端:
<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(监听的端口号);
<span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();
类似clientScoket.getInputStream获取对应输入输出字节流
- 客户端:
<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(客户端地址及占用的端口);
类似socket.getInputStream获取对应输入输出字节流
这里客户端的socket被正确创建（设定的端口无误）服务端才会accept
</code></pre>
<ol start="2">
<li>UDP:</li>
</ol>
<pre><code class="language-java">服务端:
<span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();
<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];
    <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">recivePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length, 客户端地址及占用的端口);
    socket.receive(recivePacket);

    <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">sendPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length, 客户端地址及占用的端口);
    socket.send(sendPacket);
}
客户端:
<span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();
<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];
    <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">sendPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length, 服务端地址及占用的端口);
    socket.send(sendPacket);	

    <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">recivePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(buffer, buffer.length, 服务端地址及占用的端口);
    socket.receive(recivePacket);
}
</code></pre>
<h1 id="多线程">多线程</h1>
<p>参考博客：(Thread)[<a href="https://blog.csdn.net/Justw320/article/details/131848634">https://blog.csdn.net/Justw320/article/details/131848634</a>]</p>

            
            
        </body>
        </html>