# 一些关键字
## this: 
**记住就是当前对象的引用即可**，例如
```java
public class Person {
    private String name;
    public void setName(String name) {
        this.name = name;
    }
}
```
这里就是当前对象的name，即当前对象的`private String name`，这里是处理同名，this()同理，而且this()必须放在第一行。另外，单独的this()表示调用当前类的无参构造函数，有参的话就是调用当前类的有参构造函数。

## super: 
**记住就是父类对象的引用即可**，例如
```java
public class Student extends Person {
    private String name;
    public void setName(String name) {
        super.setName(name);
    }
}
```
那么这里就是父类的name，即父类的`private String name`，这里是处理同名，super()同理。
其他的和this()一样，**但是super()由于继承机制，必须放在重写的父类方法的内第一行，而不能放在重写父类方法的外部。**

## static:
- 被static修饰的变量或者方法，是属于类的，而不是属于对象的，*即静态变量或者静态方法，可以直接通过类名来访问，而不需要实例化对象。*
- **静态方法中不能使用this和super关键字**，因为静态方法是属于类的，而不是属于对象的，所以this和super关键字是不能使用的。
- **静态类只能访问静态变量或者静态方法，反之非静态类可以随意访问静态变量或者静态方法**。
- **static不是全局变量。一个属性被写在类最外部，那么这个属性就是全局变量。而static是将属性变成静态属性，可通过类名来直接访问**。
- 一个类实例化，该类中带static是属于类的而不是对象，故无论实例化多少个对象都共享该属性，而不带static的属性则每实例化一个都是不同的属性，例如
```java
public class Person {
    private static String name;
    private String age;
}
```
**age实例化的age1，age2，age3都是不同的，而name实例化的name1，name2，name3都是相同的**。

---
# 一些方法及一些必要的基本概念
## newString():
new String(byte[] bytes, int offset, int length, String charsetName)
- bytes：这是一个 byte 类型的数组，它包含了需要转换为字符串的字节数据。在文件读取的场景中，这个数组通常是从文件中读取到的字节内容。
- offset：这是一个整数，表示从 bytes 数组的哪个位置开始进行转换。索引从 0 开始计数。例如，若 - - offset 为 0，则从数组的第一个字节开始转换。
- length：同样是一个整数，指定了要转换的字节数量。它决定了从 offset 位置开始，取多少个字节进行字符串转换。
- charsetName：***这是一个字符串，代表了字符编码的名称,所以对于非utf-8编码的字节数组可用词方法转换***

## try-catch:
- try-catch: 用于捕获异常，当try中的代码出现异常时，会跳转到catch中，catch中的代码会被执行,格式为
```java
try {
    // 可能会抛出异常的代码 
}
catch (Exception e) {
    // 异常处理代码 
}
```
- try-resource-catch: 除了捕获异常，还可以用于资源的释放，格式为
```java
try (Resource resource = new Resource()) {
    // 使用资源的代码
}
catch (Exception e) {
    // 异常处理代码 
}
```
**注意，这里的资源是所有相关的资源都会关闭,`BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()))`不仅关闭了BufferedReader还会关闭右边包括socket在内的所有资源。**

- try-finally-catch: 除了捕获异常，还可以用于资源的释放，格式为
```java
try {
    // 可能会抛出异常的代码
}
finally {
    // 无论是否抛出异常，都会执行的代码
}
```

- **一些必须要抛出异常的方法：如IO、Socket、线程、数据库等**。

## 继承：
- 父类可以有多个子类，子类可以有多个子类，但是子类只能有一个父类。
- 子类继承父类的所有属性和方法，但是父类的私有属性和方法不能被继承，但在父类建立公共的方法来访问，如getter和setter方法。
- **子类直接使用父类的属性，*重写*父类的方法**，也可以添加新的属性和方法。

## 接口：
- 接口可以被多个类实现，一个类可以实现多个接口。
- **接口全部是抽象方法。而抽象类可以有抽象方法也可以有非抽象方法。**
- 接口不能被实例化，但是可以被实现。
- 接口可以继承接口，但是不能继承类。

## 内部类：
1. **成员内部类**，格式为：
```java
class Outer {
    class Inner {
        // 内部类的代码
    }
}
```
- 成员内部类可以访问外部类的所有属性和方法，包括私有属性和方法。***（除了静态内部类另外的都和成员内部类相同）***
- 成员内部类可以被实例化，但是必须先实例化外部类，然后再实例化内部类,格式为：
```java
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
或
Outer.Inner inner = new Outer().new Inner();
```
2. 静态内部类
- 静态内部类可以访问外部类的所有**静态**属性和方法，包括私有静态属性和方法。
- 静态内部类可以被实例化，但是不需要实例化外部类,格式为：`Outer.Inner inner = new Outer.Inner();`
3. 局部内部类
局部内部类权限和成员内部类一样，但是局部内部类只能在方法中定义和使用，不能在类中定义和使用。
4. **匿名内部类**
匿名内部类用于只是用一次的类，可以继承一个父类或者实现一个接口(都是重写方法)，继承和接口的格式都类似为：
```java
MyClass class = new MyClass(可选参数) {
    // 重写MyClass中的方法
}
```

## lambda表达式：
lambda表达式的语法为：
```java
(参数列表) -> {
    // 方法体
}
如
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        // 方法体
    }
});
用lambda表达式表示为（由于run方法没有参数故参数列表也没有）：
Thread t = new Thread(() -> {
                    // 方法体
                }).start();

```

## while（true）
while（true）为除非被停止的死循环，可以用作需要一直运行的方法。**另外死循环会导致程序一直停在这出不来，所以对于所有死循环，如果该程序还有其他需要运行的，需要给死循环开启一个线程**

## 数值转化：
- 强制类型转换：`(类型)变量名`，高精度向低精度转换时会丢失精度，低精度向高精度转换时会自动转换，*精度排行：byte(8) < short(16) < int(32) < long(32) < float(32) < double(64)。*
如`short a= 8;int b = (int)a` 
- 字符串和数值的转换（以int为例）：字符转整型有`Integer.parseInt(String s)`和`Integer.valueOf(String s)`，整型转字符有`String.valueOf(int i)`和`Integer.toString(int i)`。
- 日期和字符串的转换：时间和字符串:format parse 格式:××formatter，例如：
```java
    // 获取当前日期时间
    LocalDateTime now = LocalDateTime.now();
    // 定义日期格式
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    // 将日期转换为字符串
    String dateString = now.format(formatter);
  
    // 定义日期字符串
    String dateString = "2024-10-01 12:30:00";
    // 定义日期格式
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    // 将字符串转换为日期
    LocalDateTime date = LocalDateTime.parse(dateString, formatter);
```

## 计时：
- System.currentTimeMillis()-start(start为在开始计时的System.currentTimeMillis())
- 用schedule
    - schedule(TimerTask task, long delay)：在指定延迟delay（以毫秒为单位）后执行task任务。
    - schedule(TimerTask task, Date time)：在指定的Date时间执行task任务。
    - schedule(TimerTask task, long delay, long period)：在延迟delay毫秒后开始执行task任务，之后每隔period毫秒重复执行。
    - schedule(TimerTask task, Date firstTime, long period)：在firstTime指定的时间开始执行task任务，之后每隔period毫秒重复执行。
    - 使用固定格式：
    ```java
    Timer timer = new Timer();
    TimerTask timerTask = new TimerTask() {
	public void run(){
        // 任务代码
			};
    timer.schedule(参数);}
    ```
---
# IO流：
参考博客：(IO流)[https://blog.csdn.net/a1405/article/details/116766237]

***IO流，读的时候通过输入流读取数据，写的时候写入输出流，然后通过转到相应对象***
## 字节流
字节流以字节为单位进行数据的读写操作，可处理任意类型的数据，如图片、音频、视频等，在文件上传、下载、传输等场景中广泛应用。使用时需注意关闭输入输出流，否则可能导致数据写入失败。
- 节点流
FileInputStream 和 FileOutputStream：用于文件的读取和写入操作，可实现文件复制等功能。在开发中，文件的上传、下载等操作常使用这两个节点流，通常会与装饰后的处理流配合使用。（**这个读写的对象都是文件**）
- 处理流:ByteArrayInputStream 和 ByteArrayOutputStream：这个内部维护了一个字节数组，即**读写的对象是字节数组**。
那么除了以上还能想到可以将字节数组转化为字节流，就是直接创造一个输入流对象，参数是你要转的字节流即可。
以及反过来，那么前提是输入流里有数据可以转换，读取后**注意读取返回的是int**，这里有的话就用输出处理流write写入，在toString方法转成字符。
- 缓冲流：BufferedInputStream 和 BufferedOutputStream 是字节流的缓冲流，是一个装饰装饰字节流（即获取字节流对象），通过设置缓冲区，减少与数据源的交互次数，提高数据传输效率。(**节点流每次只能读一个字节，而缓冲流可以一次读多个字节即字节数组**)
## 字符流
字符流以字符为单位进行数据的读写操作，主要用于处理纯文本文件。在进行纯文本文件的 I/O 操作时，通常会配合处理流一起使用。
- 节点流
FileReader 和 FileWriter：用于纯文本文件的读取和写入操作，针对文本数据的处理更加方便。
- 处理流:
StringReader 和 StringWriter：这个内部维护了一个字符串或字符数组等等，即**读写的对象是字符串或字符数组等**。
那么除了以上还能想到可以将字符串等转化为字节流，就是直接创造一个输入处理流对象，参数是你要转的字节流即可。
以及反过来，那么前提是流里面字符串等有数据可以转换，读取后**注意读取返回的是int**，这是有的话就用输出处理流write方法一下，同理toString转化成字符串。
- 缓冲流：BufferedReader 和 BufferedWriter 是字符流的缓冲流，同样通过设置缓冲区，提高文本数据的读写效率，并且 BufferedReader 提供了按行读取的便捷方法。(**节点流每次只能读一个字符，而缓冲流可以自动识别换行符读一行**)
- 转换流：InputStreamReader 和 OutputStreamWriter 用于在字节流和字符流之间进行转换，可指定字符编码，默认编码为 UTF - 8。在处理不同编码的文本文件时非常有用。

# Socket网络编程：
## Socket:
参考博客：(Scoket)[https://blog.csdn.net/weixin_49561506/article/details/131554978]
1. Socket（面向连接，客户端连接了服务端才能通信）:
```java
服务端:
ServerSocket serverSocket = new ServerSocket(监听的端口号);
Socket clientSocket = serverSocket.accept();
类似clientScoket.getInputStream获取对应输入输出字节流
- 客户端:
Socket socket = new Socket(服务端地址和监听的端口);
类似socket.getInputStream获取对应输入输出字节流
这里客户端的socket被正确创建（连接的端口无误，连接的地址有效）服务端才会accept
```

2. UDP（通信时再通过对方的端口地址进行通信）:
```java
服务端:
DatagramSocket socket = new DatagramSocket(监听的端口);
while(true){
    byte[] buffer = new byte[1024];
    DatagramPacket recivePacket = new DatagramPacket(buffer, buffer.length);
    socket.receive(recivePacket);
    这里接收后可以用recivePacket.getAddress()和recivePacket.getAddress()获取客户端地址以及端口，发送后也可以只是只用于提示用户发送的地址和端口信息

    DatagramPacket sendPacket = new DatagramPacket(发送的信息message，还是要转为字节数组, message.length, 客户端地址及监控的端口);
    socket.send(sendPacket);
    用getData()获取数据(获取的字节数组,且编码需要变成utf-8)
}
客户端:
DatagramSocket socket = new DatagramSocket();
while(true){
    byte[] buffer = new byte[1024];
    DatagramPacket recivePacket = new DatagramPacket(buffer, buffer.length);
    socket.receive(recivePacket);
    这里接收后可以用recivePacket.getAddress()和recivePacket.getAddress()获取服务端地址以及端口

    DatagramPacket sendPacket = new DatagramPacket(发送的信息message，还是要转为字节数组, message.length, 服务端地址及连接的端口);
    socket.send(sendPacket);	
    用getData()获取数据（获取的字节数组，且编码需要变成utf-8）
}
```

# 多线程
参考博客：(Thread)[https://blog.csdn.net/Justw320/article/details/131848634]

# 字符串：
## 常用类：
- StringBuffer：可变的字符序列，线程安全，效率低。
- StringBuilder：可变的字符序列，线程不安全，效率高。
- String：不可变的字符序列，线程安全，效率低。
## 常用方法：
- StringBuffer：append()、delete()、insert()、replace()（替换特殊字符用replaceAll）、reverse()、substring()、length()、charAt()、indexOf()
- StringBuilder：append()、delete()、insert()、replace()（替换特殊字符用replaceAll）、reverse()、substring()、length()、charAt()、indexOf()
- String：length()、charAt()、indexOf()、substring()、equals()、concat()、toLowerCase()（小写变大写）、toUpperCase()（小变大）、trim()（去两端空格）、startsWith()（是否以某某开头）、endsWith()（是否以某某结尾）、contains()（是否包含某个字符串）、replace()（替换特殊字符用replaceAll）、split()、getBytes()、toCharArray()、valueOf()。