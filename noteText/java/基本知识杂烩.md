# 一些关键字
## this: 
**记住就是当前对象的引用即可**，例如
```java
public class Person {
    private String name;
    public void setName(String name) {
        this.name = name;
    }
}
```
这里就是当前对象的name，即当前对象的`private String name`，这里是处理同名，this()同理，而且this()必须放在第一行。另外，单独的this()表示调用当前类的无参构造函数，有参的话就是调用当前类的有参构造函数。

## super: 
**记住就是父类对象的引用即可**，例如
```java
public class Student extends Person {
    private String name;
    public void setName(String name) {
        super.setName(name);
    }
}
```
那么这里就是父类的name，即父类的`private String name`，这里是处理同名，super()同理。
其他的和this()一样，**但是super()由于继承机制，必须放在重写的父类方法的内第一行，而不能放在重写父类方法的外部。**

## static:
- 被static修饰的变量或者方法，是属于类的，而不是属于对象的，*即静态变量或者静态方法，可以直接通过类名来访问，而不需要实例化对象。*
- **静态方法中不能使用this和super关键字**，因为静态方法是属于类的，而不是属于对象的，所以this和super关键字是不能使用的。
- **静态类只能访问静态变量或者静态方法，反之非静态类可以随意访问静态变量或者静态方法**。
- **static不是全局变量。一个属性被写在类最外部，那么这个属性就是全局变量。而static是将属性变成静态属性，可通过类名来直接访问**。
- 一个类实例化，该类中带static是属于类的而不是对象，故无论实例化多少个对象都共享该属性，而不带static的属性则每实例化一个都是不同的属性，例如
```java
public class Person {
    private static String name;
    private String age;
}
```
**age实例化的age1，age2，age3都是不同的，而name实例化的name1，name2，name3都是相同的**。

---
# 一些方法及一些必要的基本概念
## newString():
new String(byte[] bytes, int offset, int length, String charsetName)
- bytes：这是一个 byte 类型的数组，它包含了需要转换为字符串的字节数据。在文件读取的场景中，这个数组通常是从文件中读取到的字节内容。
- offset：这是一个整数，表示从 bytes 数组的哪个位置开始进行转换。索引从 0 开始计数。例如，若 - - offset 为 0，则从数组的第一个字节开始转换。
- length：同样是一个整数，指定了要转换的字节数量。它决定了从 offset 位置开始，取多少个字节进行字符串转换。
- charsetName：***这是一个字符串，代表了字符编码的名称,所以对于非utf-8编码的字节数组可用词方法转换***

## try-catch:
- try-catch: 用于捕获异常，当try中的代码出现异常时，会跳转到catch中，catch中的代码会被执行,格式为
```java
try {
    // 可能会抛出异常的代码 
}
catch (Exception e) {
    // 异常处理代码 
}
```
- try-resource-catch: 除了捕获异常，还可以用于资源的释放，格式为
```java
try (Resource resource = new Resource()) {
    // 使用资源的代码
}
catch (Exception e) {
    // 异常处理代码 
}
```
**注意，这里的资源是所有相关的资源都会关闭,`BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()))`不仅关闭了BufferedReader还会关闭右边包括socket在内的所有资源。**

- try-finally-catch: 除了捕获异常，还可以用于资源的释放，格式为
```java
try {
    // 可能会抛出异常的代码
}
finally {
    // 无论是否抛出异常，都会执行的代码
}
```

- **一些必须要抛出异常的方法：如IO、Socket、线程、数据库等**。

## 继承：
- 父类可以有多个子类，子类可以有多个子类，但是子类只能有一个父类。
- 子类继承父类的所有属性和方法，但是父类的私有属性和方法不能被继承，但在父类建立公共的方法来访问，如getter和setter方法。
- **子类直接使用父类的属性，*重写*父类的方法**，也可以添加新的属性和方法。

## 接口：
- 接口可以被多个类实现，一个类可以实现多个接口。
- **接口全部是抽象方法。而抽象类可以有抽象方法也可以有非抽象方法。**
- 接口不能被实例化，但是可以被实现。
- 接口可以继承接口，但是不能继承类。

## 内部类：
1. **成员内部类**，格式为：
```java
class Outer {
    class Inner {
        // 内部类的代码
    }
}
```
- 成员内部类可以访问外部类的所有属性和方法，包括私有属性和方法。***（除了静态内部类另外的都和成员内部类相同）***
- 成员内部类可以被实例化，但是必须先实例化外部类，然后再实例化内部类,格式为：
```java
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
或
Outer.Inner inner = new Outer().new Inner();
```
2. 静态内部类
- 静态内部类可以访问外部类的所有**静态**属性和方法，包括私有静态属性和方法。
- 静态内部类可以被实例化，但是不需要实例化外部类,格式为：`Outer.Inner inner = new Outer.Inner();`
3. 局部内部类
局部内部类权限和成员内部类一样，但是局部内部类只能在方法中定义和使用，不能在类中定义和使用。
4. **匿名内部类**
匿名内部类用于只是用一次的类，可以继承一个父类或者实现一个接口(都是重写方法)，继承和接口的格式都类似为：
```java
MyClass class = new MyClass(可选参数) {
    // 重写MyClass中的方法
}
```

## lambda表达式：
lambda表达式的语法为：
```java
(参数列表) -> {
    // 方法体
}
如
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        // 方法体
    }
});
用lambda表达式表示为（由于run方法没有参数故参数列表也没有）：
Thread t = new Thread(() -> {
                    // 方法体
                }).start();

```

## 数值转化：
- 强制类型转换：`(类型)变量名`，高精度向低精度转换时会丢失精度，低精度向高精度转换时会自动转换，*精度排行：byte(8) < short(16) < int(32) < long(64) < float(32) < double(64)。*
如`short a= 8;int b = (int)a` 
- 字符串和数值的转换（以int为例）：字符转整型有`Integer.parseInt(String s)`和`Integer.valueOf(String s)`，整型转字符有`String.valueOf(int i)`和`Integer.toString(int i)`。
- 日期和字符串的转换：时间和字符串:format parse 格式:××formatter，例如：
```java
    // 获取当前日期时间
    LocalDateTime now = LocalDateTime.now();
    // 定义日期格式
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    // 将日期转换为字符串
    String dateString = now.format(formatter);
  
    // 定义日期字符串
    String dateString = "2024-10-01 12:30:00";
    // 定义日期格式
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    // 将字符串转换为日期
    LocalDateTime date = LocalDateTime.parse(dateString, formatter);
```

## 计时：
- System.currentTimeMillis()-start(start为在开始计时的System.currentTimeMillis())
- 用schedule
    - schedule(TimerTask task, long delay)：在指定延迟delay（以毫秒为单位）后执行task任务。
    - schedule(TimerTask task, Date time)：在指定的Date时间执行task任务。
    - schedule(TimerTask task, long delay, long period)：在延迟delay毫秒后开始执行task任务，之后每隔period毫秒重复执行。
    - schedule(TimerTask task, Date firstTime, long period)：在firstTime指定的时间开始执行task任务，之后每隔period毫秒重复执行。
    - 使用固定格式：
    ```java
    Timer timer = new Timer();
    TimerTask timerTask = new TimerTask() {
	public void run(){
        // 任务代码
			};
    timer.schedule(参数);}
    ```
---
# IO流：
参考博客：(IO流)[https://blog.csdn.net/a1405/article/details/116766237]

***IO流，读的时候通过输入流读取数据，写的时候写入输出流，然后通过转到相应对象***
## 字节流
字节流以字节为单位进行数据的读写操作，可处理任意类型的数据，如图片、音频、视频等，在文件上传、下载、传输等场景中广泛应用。使用时需注意关闭输入输出流，否则可能导致数据写入失败。
- 节点流
FileInputStream 和 FileOutputStream：用于文件的读取和写入操作，可实现文件复制等功能。在开发中，文件的上传、下载等操作常使用这两个节点流，通常会与装饰后的处理流配合使用。（**这个读写的对象都是文件**）
- 处理流:ByteArrayInputStream 和 ByteArrayOutputStream：这个内部维护了一个字节数组，即**读写的对象是字节数组**。
那么除了以上还能想到可以将字节数组转化为字节流，就是直接创造一个输入流对象，参数是你要转的字节数组即可。
以及反过来，那么前提是输入流里有数据可以转换，读取后（**注意读取返回的是int**），这里有的话就用输出处理流write写入输出流，**输出流可用toString方法转成字符**。
- 缓冲流：BufferedInputStream 和 BufferedOutputStream 是字节流的缓冲流，是一个装饰装饰字节流（即获取字节流对象），通过设置缓冲区，减少与数据源的交互次数，提高数据传输效率。(**节点流每次只能读一个字节，而缓冲流可以一次读多个字节即字节数组**)
## 字符流
字符流以字符为单位进行数据的读写操作，主要用于处理纯文本文件。在进行纯文本文件的 I/O 操作时，通常会配合处理流一起使用。
- 节点流
FileReader 和 FileWriter：用于纯文本文件的读取和写入操作，针对文本数据的处理更加方便。
- 处理流:
StringReader 和 StringWriter：这个内部维护了一个字符串或字符数组等等，即**读写的对象是字符串或字符数组等**。
那么除了以上还能想到可以将字符串等转化为字节流，就是直接创造一个输入处理流对象，参数是你要转的字符串等即可。
以及反过来，那么前提是流里面字符串等有数据可以转换，读取后（**注意读取返回的是int**），这是有的话就用输出处理流write方法一下输出流，同理**输出流可用toString方法转成字符**。
- 缓冲流：BufferedReader 和 BufferedWriter 是字符流的缓冲流，同样通过设置缓冲区，提高文本数据的读写效率，并且 BufferedReader 提供了按行读取的便捷方法。(**节点流每次只能读一个字符，而缓冲流可以自动识别换行符读一行**)
- 转换流：InputStreamReader 和 OutputStreamWriter 用于在字节流和字符流之间进行转换，可指定字符编码，默认编码为 UTF - 8。在处理不同编码的文本文件时非常有用。

# Socket网络编程：
## Socket:
参考博客：(Scoket)[https://blog.csdn.net/weixin_49561506/article/details/131554978]
1. Socket（TCP，面向连接，客户端连接了服务端才能通信）:
```java
服务端:
ServerSocket serverSocket = new ServerSocket(监听的端口号);
Socket clientSocket = serverSocket.accept();
类似clientScoket.getInputStream获取对应输入输出字节流
- 客户端:
Socket socket = new Socket(服务端地址和监听的端口);
类似socket.getInputStream获取对应输入输出字节流
这里客户端的socket被正确创建（连接的端口无误，连接的地址有效）服务端才会accept
```

2. UDP（通信时再通过对方的端口地址进行通信）:
```java
服务端:
DatagramSocket socket = new DatagramSocket(监听的端口);
while(true){
    byte[] buffer = new byte[1024];
    DatagramPacket recivePacket = new DatagramPacket(buffer, buffer.length);
    socket.receive(recivePacket);
    这里接收后可以用`recivePacket.getAddress()`和`recivePacket.getAddress()`获取客户端地址以及端口，发送后也可以只是只用于提示用户发送的地址和端口信息

    DatagramPacket sendPacket = new DatagramPacket(发送的信息message，还是要转为字节数组, message.length, 客户端地址及监控的端口);
    socket.send(sendPacket);
    用getData()获取数据(获取的字节数组,且编码需要变成utf-8)
}
客户端:
DatagramSocket socket = new DatagramSocket();
while(true){
    byte[] buffer = new byte[1024];
    DatagramPacket recivePacket = new DatagramPacket(buffer, buffer.length);
    socket.receive(recivePacket);
    这里接收后可以用`recivePacket.getAddress()`和`recivePacket.getAddress()`获取服务端地址以及端口

    DatagramPacket sendPacket = new DatagramPacket(发送的信息message，还是要转为字节数组, message.length, 服务端地址及连接的端口);
    socket.send(sendPacket);	
    用getData()获取数据（获取的字节数组，且编码需要变成utf-8）
}
```

# 多线程
## 一些总结：
多线程就是让程序同时多件事，例如服务器实时监控客户端状态，而控制多线程即让线程安全有如同步互斥锁（synchronized()）、睡眠、让步（yeild）、线程加入（join（先要开启一个线程才能加入，加入后只等该线程完成才进行被加入线程并独占完成））
参考博客：(Thread)[https://blog.csdn.net/Justw320/article/details/131848634]
## while（true）
while（true）为除非被停止的死循环，可以用作需要一直运行的方法。**另外死循环会导致程序一直停在这出不来，所以对于所有死循环，如果该程序还有其他需要运行的，需要给死循环开启一个线程**，***另外在while（true）中可以用`Thread.sleep(100)`每运行一次休眠0.1即每0.1秒运行一次，在运行该程序的情况下定时休息而防止CPU占用过高，适用于一些不需频繁运行的功能，如记录输入字的字数、单个游戏角色的实时状态等等***

# 字符串：
## 常用类：
- StringBuffer：可变的字符序列，线程安全，效率低。
- StringBuilder：可变的字符序列，线程不安全，效率高。
- String：不可变的字符序列，线程安全，效率低。
## 常用方法：
- StringBuffer：append()、delete()、insert()、replace()（替换特殊字符用replaceAll）、reverse()、substring()、length()、charAt()、indexOf()
- StringBuilder：append()、delete()、insert()、replace()（替换特殊字符用replaceAll）、reverse()、substring()、length()、charAt()、indexOf()
- String：length()、charAt()、indexOf()、substring()、equals()、concat()、toLowerCase()（小写变大写）、toUpperCase()（小变大）、trim()（去两端空格）、startsWith()（是否以某某开头）、endsWith()（是否以某某结尾）、contains()（是否包含某个字符串）、replace()（替换特殊字符用replaceAll）、split()、getBytes()、toCharArray()、valueOf()。

# 数据存储以及数据结构：
## 各种数值类型的存储：
前情提要，一个英文字符占1个字节，***一个中文字符在主流的GBK编码占2个字节，而在UTF-8编码占一般认为3个字节（生僻字或特殊字符可能占4个）***
- 整数：int[$2^{31}$-1，$-2^{31}$]、short[$2^{15}$-1，$-2^{15}$]、long[$2^{63}$-1，$-2^{63}$]、byte[$2^7$-1，$-2^7$]
- 浮点数：float[3.4*$10^{38}$，$-3.4*10^{38}$]、double[1.7*$10^{308}$，1.7*$10^{308}$]
- 字符：char[0，$2^{16}$]
## 数组和集合存储，需要结合数据结构理解：
### ***使用场景***:
- 数组和列表适合固定大小、要频繁高性能访问的场景；
- 集合适合动态大小、多样化、多对象操作的场景
  - 集合中list接口和Queue接口的适用数据不唯一有序，
  - hashSet唯一无序，TreeSet唯一有序
  - Map接口的适用数据键值对，hashMap唯一无序，TreeMap唯一有序
- 字符串适合处理文本信息。
### 详细介绍及常用方法
- 数组：存储固定长度的相同类型的数据，**最大的长度为int的最大值**。aslist变列表
- 列表：存储固定长度的相同类型的数据，列表的长度在创建时就确定，无法改变。toArray转对象数组
- 集合：存储可变长度的不同类型的数据，集合的长度可以动态改变。
  - 集合的分类（一层层都是继承关系，子类继承父类所用方法）：
    - Collection：
      - **List**：存储一组不唯一、有序（插入顺序）的对象。（**这里子类特殊是可以直接用=转成list的**，而同级转换到其他如ArrayList转到LinkedList直接在建立LinkedList加上ArrayList参数即可）
        - ArrayList：基于数组实现故插入和删除效率低，动态数组，支持随机访问，线程不安全。
          *常用方法*：add(),get(),remove(),set(),size(),contains(),isEmpty(),indexOf()(返回数据索引),clear(),equals()，addAll(加另一个集合)等等
        - LinkedList：基于双向链表实现故插入和删除效率高，不支持随机访问，线程不安全。  
          *常用方法*：方法和ArrayList类似，就是多了addFirst()(在开头添加),addLast()(在结尾添加)等等关于首尾的方法。另外，**还可以作为栈、队列使用，即链栈和链队列**,相应方法如下：
          链栈：出栈push()或addFirst()(后面包括队就不写或了，自行找对应方法)，入栈pop()，查看栈顶元素peek()，判断栈是否为空empty()
          链队列: 出队poll()，入队offer()，查看队首元素peek()，判断队是否为空isEmpty()
        - Vector：基于数组实现，线程安全。类似于ArrayList，常用方法也类似。
          - Stack：基于Vector实现，线程安全，后进先出（LIFO）的栈结构,**即顺序栈**，方法就多了pop()(出栈),push()(入栈),peek()(查看栈顶元素)，empty()(判断栈是否为空)，search()(查找元素在栈中的位置)等等
      - Queue：存储一组不唯一、有序（先进先出）的对象。
        - Deque：双端队列，支持在队列的两端进行插入和删除操作。线程不安全。
          - ArrayDeque：基于数组实现的双端队列。**即顺序队列**。
          - LinkedList：基于链表实现的双端队列。*但其实用linkedList即可*
        - ArrayBlockingQueue：基于数组实现的有界阻塞队，用于多线程环境，
          当队列已满时，如果有线程尝试向队列中添加元素，该线程会被阻塞，直到队列中有空间可用；当队列为空时，如果有线程尝试从队列中移除元素，该线程也会被阻塞，直到队列中有元素可用。
        - LinkedBlockingQueue：基于链表实现的无界阻塞队列。线程安全。
        - PriorityQueue：基于堆实现的优先队列，元素按照优先级排序，至于如何自定义优先级即排序规则，我们在TreeSet说明。
        - PriorityBlockingQueue：基于优先级堆实现的无界阻塞队列。
      - **Set**：
        - HashSet：基于哈希表实现，不保证元素的顺序。**基于哈希码（hashCode()）和equals方法判断表中元素是否相等，即每个元素只能出现一次**且无索引无序。  
          *常用方法*：也和List类似，就是有了哈希码来判断是否相等
        - LinkedHashSet：基于哈希表和链表实现，保证元素的插入顺序。其他和HashSet类似。
        - TreeSet：基于红黑树实现，元素按照自然顺序排序，也可以自定义排序规则。
          常用方法：和list类似。  
          #### ***自定义排序规则***：
          1. 实现Comparable接口，重写compareTo方法。
          ```java
          public class Person implements Comparable<Person> {
              private String name;
              private int age;
              @Override
              public int compareTo(Person other) {
                  // 按照年龄升序排序
                  return Integer.compare(this.age, other.age);;
              }
          }主类中实例化该类自动按照自定义的年龄升序排序
          ```
          2. 实现Comparator接口，重写compare方法。
          ```java
          public class Person {
              private String name;
              private int age;
              //略其他方法
          }
          主类中实例化该类，使用匿名内部类实现Comparator接口，重写compare方法。
          TreeSet<Person> set = new TreeSet<>(new Comparator<Person>() {
              @Override
              public int compare(Person o1, Person o2) {
                  // 按照年龄升序排序
                  return Integer.compare(o1.getAge(), o2.getAge());
              }
          });也可以不用匿名内部类，直接实例化一个重写了compare方法Comparator对象，然后作为参数传入TreeSet中，这里是为了简化代码。
          ```
          ***这里补充一个重要知识点，对象的toString方法，返回的是对象名和哈希码，要想得到相应的数值，因该重写toString方法。*** 如以上两个例子都应该重写toString方法。
      - **Map**：存储一组**键值对**，每个键对应一个值。
      - HashMap：基于哈希表实现，不保证键的顺序。  
        *常用方法*：put(key,value),get(key),remove(key),containsKey(key),containsValue(value),size(),isEmpty(),clear(),keySet()（得到Set类型的键值集合）,values()（得到Collection的值集合）,entrySet()(获取Set类型的Map.Entry集合，有getkey和getvalue方法)等等
      - LinkedHashMap：基于哈希表和链表实现，保证键的插入顺序。    
        *常用方法*：和HashMap类似，就是多了putFirst(key,value),putLast(key,value),removeFirst(),removeLast(),getFirst(),getLast()等等关于首尾的方法。 
      - TreeMap：基于红黑树实现，键按照自然顺序排序。常用方法和LinkedHashMap类似。
      - Hashtable：基于哈希表实现，线程安全，不允许键或值为null。常用方法和HashMap类似。
      - ConcurrentHashMap：基于哈希表实现，线程安全。常用方法和HashMap类似。
- 一些线程安全的集合或包装类：如synchronizedList，synchronizedSet，synchronizedMap，Collections.synchronizedList，Collections.synchronizedSet，Collections.synchronizedMap，CopyOnWriteArrayList，CopyOnWriteArraySet，ConcurrentHashMap等等,**这些集合或包装类的效率较低，所以一般情况下不使用，但如果程序对线程安全的要求较高时也必须可以使用这些线程安全的集合或包装类**。具体使用自行搜索。
- 集合遍历方法：
  - 迭代器（常用，但不能在迭代时修改数据）：Iterator
    - 常用方法：hasNext(),next(),remove() （即删除用迭代器的remove方法）
  - 增强for循环（更简单，但不能在迭代时修改和删除数据，但可以用Iterator.remove()删除当前数据）：for(E e : 要遍历的对象)  (E为集合中元素的类型)
  - 普通for循环（通用,对于要修改或删除数据时使用）：for 
  - 对于Map集合的遍历：
    - 通过keySet()遍历：
    ```java
    Map<String, Integer> map = new HashMap<>();
    map.put("A", 1);
    //略多次put
    for (String key : map.keySet()) {
        int value = map.get(key);
        System.out.println(key + ": " + value);
    }
    ```
    - 通过entrySet()遍历：
    ```java
    Map<String, Integer> map = new HashMap<>();
    map.put("A", 1);
    //略多次put
    for (Map.Entry<String, Integer> entry : map.entrySet()) {
        String key = entry.getKey();
        int value = entry.getValue();
        System.out.println(key + ": " + value);
    }
    ```
    - 通过values()遍历：类似于keySet()，略
- 参考博客：(集合)[https://blog.csdn.net/2301_79842503/article/details/140886252]

# 泛型：
- 泛型的本质是参数化类型，即把类型作为参数传递给类或方法。
- 泛型的优点是可以提高代码的复用性和安全性，避免了类型转换的错误。
- 泛型的使用方法：
  - 定义泛型类时，需要在类名后面加上尖括号，并在尖括号中指定泛型类型参数。 
    比如ArrayList<E>，其中E就是泛型类型参数。
  - 泛型类可以有多个泛型类型参数，每个参数之间用逗号分隔。
    比如HashMap<K,V>，其中K和V就是泛型类型参数。 
  - 泛型类可以在类的成员变量、方法参数和方法返回值中使用泛型类型参数。  
  - 泛型类的实例化时需要指定泛型类型参数的具体类型。 
  - 那对于加了泛型的类，该类的对象可以调用泛型类的方法，但是不能调用泛型类的属性，**该类的泛型方法的参数和返回值也需要指定泛型类型参数的具体类型**。就比如上面集合几乎都是泛型类，都有泛型方法，如：
  ```java 
  class Person implements Comparable<Person> {
      private String name;
      private int age;
  
      public Person(String name, int age) {
          this.name = name;
          this.age = age;
      }
      public int gatAge() {
          return age;
  }
      @Override //重写compareTo方法,这里用不到就随便写了
      public int compareTo(Person o) {
          return 0;
      }
      public String toString() {
          return "Person{name='" + name + "', age=" + age + '}';
      }
  }

  public class test {
      public static void main(String[] args)  {
          HashSet<Person> h = new HashSet<Person>();
          h.add(new Person("a",1));
          h.add(new Person("b",2));
          h.add(new Person("c",3));
          for(Person e : h) {
              System.out.println(e);
          }
      }
  }
  ```
  hashSet的泛型方法add()和遍历都得用Person对象。那么可以得出使用泛型类**可以灵活的指定泛型类型参数的具体类型，而不用像普通类那样指定具体类型**，当我们需要灵活的指定泛型类型参数的具体类型时，可以使用泛型类定义泛型类方法，**参数类型和返回值类型都用泛型参数指定**。
  - ***泛型参数***：所有大写字母都可以作为泛型参数，但为了代码的可读性，一般约定使用以下字母作为泛型参数：
    - K - Key（键）
    - V - Value（值）
    - N - Number（数值类型）
    - E - Element (在集合中使用，因为集合中存放的是元素)
    - T - Type（java类型，最常用最广泛的约定参数）
    - K - Key（键）V - Value（值） N - Number（数值类型）等等
    - K,V - 键值对
    - 两个或两个以上的泛型参数用逗号分隔 按A，B，C顺序命名
# 枚举类：
- 定义：
  ```java
  enum 枚举类名 {
      枚举值1,
      枚举值2,
      ...
  }
  ```
- 特性：
  - 枚举类中的每个常量都是该枚举类的一个实例，并且是单例的，如：
    ```java
    enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
    }

    public class EnumSingleton {
        public static void main(String[] args) {
            Day day1 = Day.MONDAY;//因为每个常量都是该枚举类的一个实例，故这里可以用枚举类名.枚举值来创建实例
            Day day2 = Day.MONDAY;
            System.out.println(day1 == day2); // 输出: true
        }
    }
    ```
    这里的day1和day2是同一个实例。
  - 枚举类可以使用 Enum 类提供的一些方法，如：name()、ordinal()(枚举常量在枚举类中声明的顺序，从 0 开始计数)、values()（得到所以枚举值）等等。
  - 枚举类可以用自己的属性和方法，如：
    ```java
    enum Season {
        //因为每个常量都是该枚举类的一个实例，故枚举值也可看做一个实例对象，故这里可以用构造函数来初始化属性
        SPRING("温暖"), SUMMER("炎热"), AUTUMN("凉爽"), WINTER("寒冷");

        private final String description;

        // 构造函数
        Season(String description) {
            this.description = description;
        }

        // 获取描述信息的方法
        public String getDescription() {
            return description;
        }
    }

    public class EnumWithAttributes {
        public static void main(String[] args) {
            for (Season season : Season.values()) {
                System.out.println(season + ": " + season.getDescription());
            }
        }
    }
    ```
    这里的枚举类Season有自己的属性description，且有自己的方法getDescription()。
  - 枚举类可以实现接口，如：
    ```java
    interface SeasonAction {
        void action();
    }

    enum Season implements SeasonAction {
        SPRING {
            @Override
            public void action() {
                System.out.println("外出踏青");
            }
        },
        SUMMER {
            @Override
            public void action() {
                System.out.println("游泳解暑");
            }
        //略重复实现的代码
        };
    }

    public class EnumImplementingInterface {
        public static void main(String[] args) {
            //用Season.values()来遍历枚举类
            for (Season season : Season.values()) {
                System.out.print(season + " 适合: ");
                season.action();
            }
        }
    }
 - 枚举类在switch语句中的使用：
  ```java
  enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
    }

    public class EnumSwitchExample {
        public static void main(String[] args) {
            Day today = Day.MONDAY;
            switch (today) {
                case MONDAY:
                    System.out.println("开始新的一周，加油工作！");
                    break;
                //略重复的代码
                case SUNDAY:
                    System.out.println("周日，准备迎接新一周！");
                    break;
            }
        }
    }
- 枚举类的使用场景：
  - **当需要定义一组固定的常量时，可以使用枚举类，如颜色选择、星期选择、策略选择等。**
  - 当需要在 switch 语句中使用枚举类型时，可以使用枚举类。